input {
  udp {
    port => 5140
    type => "pfsense"
  }
  tcp {
    port => 5140
    type => "pfsense"
  }
}

filter {
  if [type] == "pfsense" {
    
    # Try RFC5424 format first (version OPTIONAL - FIX)
    grok {
      match => { 
        "message" => "<%{POSINT:syslog_pri}>(?:%{POSINT:syslog_version} )?%{TIMESTAMP_ISO8601:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{NOTSPACE:syslog_program}(?:\[%{POSINT:syslog_pid}\])? (?:%{NOTSPACE:syslog_msgid})? (?:%{NOTSPACE:syslog_sd})? %{GREEDYDATA:syslog_message}" 
      }
      overwrite => [ "syslog_message" ]
      tag_on_failure => ["_try_bsd_format"]
    }
    
    # If RFC5424 failed, try BSD syslog format
    if "_try_bsd_format" in [tags] {
      mutate { remove_tag => ["_try_bsd_format"] }
      
      grok {
        match => {
          "message" => "<%{POSINT:syslog_pri}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{NOTSPACE:syslog_hostname} %{NOTSPACE:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}"
        }
        overwrite => ["syslog_message"]
      }
    }
    
    # Parse pfSense filterlog
    if [syslog_program] == "filterlog" {
      
      mutate {
        strip => ["syslog_message"]
      }
      
      csv {
        source => "syslog_message"
        columns => [
          "rule_number", "sub_rule", "anchor", "tracker", "interface",
          "reason", "action", "direction", "ip_version", "tos", "ecn",
          "ttl", "id", "offset", "flags", "protocol_id", "protocol",
          "length", "src_ip", "dest_ip", "src_port", "dest_port",
          "data_length", "tcp_flags", "sequence", "ack", "window",
          "urg", "options"
        ]
        separator => ","
        skip_empty_columns => true
      }
      
      # Convert numeric fields
      if [rule_number] and [rule_number] != "" {
        mutate { convert => { "rule_number" => "integer" } }
      }
      
      if [tracker] and [tracker] != "" {
        mutate { convert => { "tracker" => "integer" } }
      }
      
      if [ip_version] and [ip_version] != "" {
        mutate { convert => { "ip_version" => "integer" } }
      }
      
      if [ttl] and [ttl] != "" {
        mutate { convert => { "ttl" => "integer" } }
      }
      
      if [protocol_id] and [protocol_id] != "" {
        mutate { convert => { "protocol_id" => "integer" } }
      }
      
      if [length] and [length] != "" {
        mutate { convert => { "length" => "integer" } }
      }
      
      if [src_port] and [src_port] != "" {
        mutate { convert => { "src_port" => "integer" } }
      }
      
      if [dest_port] and [dest_port] != "" {
        mutate { convert => { "dest_port" => "integer" } }
      }
      
      if [data_length] and [data_length] != "" {
        mutate { convert => { "data_length" => "integer" } }
      }
      
      mutate {
        add_field => { "log_type" => "firewall" }
      }
      
      # Reverse DNS lookup cho source IP (nếu là external)
      if [src_ip] and "external_source" in [tags] {
        mutate {
          add_field => { "src_hostname" => "%{src_ip}" }
        }
        
        dns {
          reverse => ["src_hostname"]
          action => "replace"
          timeout => 2
          hit_cache_size => 10000
          hit_cache_ttl => 3600
          failed_cache_size => 5000
          failed_cache_ttl => 300
        }
      }
      
      # Reverse DNS lookup cho destination IP (nếu là external)
      if [dest_ip] and "external_dest" in [tags] {
        mutate {
          add_field => { "dest_hostname" => "%{dest_ip}" }
        }
        
        dns {
          reverse => ["dest_hostname"]
          action => "replace"
          timeout => 2
          hit_cache_size => 10000
          hit_cache_ttl => 3600
          failed_cache_size => 5000
          failed_cache_ttl => 300
        }
      }
      
      # Phân loại service dựa trên port
      if [dest_port] {
        if [dest_port] == 53 {
          mutate { 
            add_field => { "service_name" => "DNS" }
            add_tag => ["dns_traffic"]
          }
        } else if [dest_port] == 80 {
          mutate { 
            add_field => { "service_name" => "HTTP" }
            add_tag => ["web_traffic"]
          }
        } else if [dest_port] == 443 {
          mutate { 
            add_field => { "service_name" => "HTTPS" }
            add_tag => ["web_traffic", "encrypted_traffic"]
          }
        } else if [dest_port] == 22 {
          mutate { 
            add_field => { "service_name" => "SSH" }
            add_tag => ["ssh_traffic"]
          }
        } else if [dest_port] == 21 or [dest_port] == 20 {
          mutate { 
            add_field => { "service_name" => "FTP" }
            add_tag => ["ftp_traffic"]
          }
        } else if [dest_port] == 25 or [dest_port] == 587 or [dest_port] == 465 {
          mutate { 
            add_field => { "service_name" => "SMTP" }
            add_tag => ["email_traffic"]
          }
        } else if [dest_port] == 3389 {
          mutate { 
            add_field => { "service_name" => "RDP" }
            add_tag => ["rdp_traffic"]
          }
        } else if [dest_port] == 445 or [dest_port] == 139 {
          mutate { 
            add_field => { "service_name" => "SMB" }
            add_tag => ["smb_traffic"]
          }
        } else if [dest_port] >= 1024 and [dest_port] <= 49151 {
          mutate { 
            add_field => { "service_name" => "Registered Port" }
            add_tag => ["registered_port"]
          }
        } else if [dest_port] >= 49152 {
          mutate { 
            add_field => { "service_name" => "Dynamic/Private Port" }
            add_tag => ["ephemeral_port"]
          }
        } else {
          mutate { 
            add_field => { "service_name" => "Other" }
          }
        }
      }
      
      # Phát hiện potential port scanning
      if [src_port] and [dest_port] {
        if [src_port] > 1024 and [dest_port] < 1024 {
          mutate { add_tag => ["potential_scan"] }
        }
      }
      
      # Phát hiện DNS queries bất thường
      if [dest_port] == 53 and [dest_ip] and [dest_ip] !~ /^(10\.0\.1\.1|8\.8\.8\.8|8\.8\.4\.4|1\.1\.1\.1|1\.0\.0\.1)/ {
        mutate { add_tag => ["non_standard_dns"] }
      }
      
      # Phát hiện high volume traffic
      if [length] {
        if [length] > 1400 {
          mutate { add_tag => ["large_packet"] }
        } else if [length] < 100 {
          mutate { add_tag => ["small_packet"] }
        }
      }
      
      # TCP flags analysis
      if [tcp_flags] {
        if [tcp_flags] == "S" {
          mutate { 
            add_field => { "tcp_state" => "SYN" }
            add_tag => ["tcp_syn"]
          }
        } else if [tcp_flags] =~ /F/ {
          mutate { 
            add_field => { "tcp_state" => "FIN" }
            add_tag => ["tcp_fin"]
          }
        } else if [tcp_flags] =~ /R/ {
          mutate { 
            add_field => { "tcp_state" => "RST" }
            add_tag => ["tcp_reset"]
          }
        } else if [tcp_flags] == "SA" {
          mutate { 
            add_field => { "tcp_state" => "SYN-ACK" }
            add_tag => ["tcp_synack"]
          }
        }
      }
      
      # TTL analysis
      if [ttl] {
        if [ttl] >= 60 and [ttl] <= 64 {
          mutate { add_field => { "suspected_os" => "Linux/Unix" } }
        } else if [ttl] >= 124 and [ttl] <= 128 {
          mutate { add_field => { "suspected_os" => "Windows" } }
        } else if [ttl] >= 252 and [ttl] <= 255 {
          mutate { add_field => { "suspected_os" => "Network Device" } }
        } else if [ttl] < 30 {
          mutate { 
            add_field => { "suspected_os" => "Suspicious Low TTL" }
            add_tag => ["suspicious_ttl"]
          }
        }
      }
      
      # Add action tags
      if [action] == "block" {
        mutate { add_tag => ["blocked"] }
      } else if [action] == "pass" {
        mutate { add_tag => ["allowed"] }
      }
      
      # Tag internal/external source
      if [src_ip] and [src_ip] =~ /^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[0-1])\.)/ {
        mutate { add_tag => ["internal_source"] }
      } else if [src_ip] and [src_ip] != "0.0.0.0" and [src_ip] != "" {
        mutate { add_tag => ["external_source"] }
        
        geoip {
          source => "src_ip"
          target => "source"
          database => "/usr/share/logstash/data/plugins/filters/geoip/CC/GeoLite2-City.mmdb"
        }
      }
      
      # Tag internal/external destination
      if [dest_ip] and [dest_ip] =~ /^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[0-1])\.)/ {
        mutate { add_tag => ["internal_dest"] }
      } else if [dest_ip] and [dest_ip] !~ /^(224\.|0\.0\.0\.0|fe80|ff02)/ and [dest_ip] != "" {
        mutate { add_tag => ["external_dest"] }
        
        geoip {
          source => "dest_ip"
          target => "destination"
          database => "/usr/share/logstash/data/plugins/filters/geoip/CC/GeoLite2-City.mmdb"
        }
      }
      
      # Tạo unique session ID
      if [src_ip] and [dest_ip] and [src_port] and [dest_port] {
        fingerprint {
          source => ["src_ip", "dest_ip", "src_port", "dest_port", "protocol"]
          target => "session_id"
          method => "SHA256"
          concatenate_sources => true
        }
      }
      
      # Tạo flow ID
      if [src_ip] and [dest_ip] and [protocol] {
        fingerprint {
          source => ["src_ip", "dest_ip", "protocol"]
          target => "flow_id"
          method => "SHA256"
          concatenate_sources => true
        }
      }
      
      # Tính packet timestamp
      ruby {
        code => '
          event.set("packet_timestamp_ms", (event.get("@timestamp").to_f * 1000).to_i)
        '
      }
      
      # Tính packet efficiency
      if [data_length] and [length] and [length] > 0 {
        ruby {
          code => '
            data_len = event.get("data_length").to_f
            total_len = event.get("length").to_f
            if total_len > 0
              efficiency = (data_len / total_len * 100).round(2)
              event.set("packet_efficiency", efficiency)
              
              if efficiency < 20
                event.tag("high_overhead")
              end
            end
          '
        }
      }
      
      mutate {
        remove_field => ["syslog_msgid", "syslog_sd"]
      }
    }
    
    # Parse DHCP logs
    else if [syslog_program] == "dhcpd" or [syslog_program] == "dhclient" {
      grok {
        match => { 
          "syslog_message" => [
            "DHCP%{WORD:dhcp_action} (on|from) %{IP:dhcp_ip}",
            "DHCP%{WORD:dhcp_action} for %{IP:dhcp_ip}",
            "DHCP%{WORD:dhcp_action} on %{NOTSPACE:dhcp_interface} to %{IP:dhcp_server}",
            "%{GREEDYDATA:dhcp_message}"
          ]
        }
      }
      mutate {
        add_field => { "log_type" => "dhcp" }
      }
    }
    
    # Parse OpenVPN logs
    else if [syslog_program] =~ /openvpn/ {
      grok {
        match => {
          "syslog_message" => [
            "%{IP:vpn_client_ip}:%{NUMBER:vpn_client_port} %{GREEDYDATA:vpn_message}",
            "%{GREEDYDATA:vpn_message}"
          ]
        }
      }
      mutate {
        add_field => { "log_type" => "vpn" }
      }
    }
    
    # Parse web GUI logs
    else if [syslog_program] == "php-fpm" or [syslog_program] == "nginx" {
      mutate {
        add_field => { "log_type" => "web_gui" }
      }
    }
    
    # System logs
    else {
      mutate {
        add_field => { "log_type" => "system" }
      }
    }
    
    # Parse timestamp
    if [syslog_timestamp] {
      # Try ISO8601 first (RFC5424)
      date {
        match => [ "syslog_timestamp", "ISO8601" ]
        target => "@timestamp"
        timezone => "Asia/Ho_Chi_Minh"
        tag_on_failure => ["_dateparsefailure_iso"]
      }
      
      # If ISO8601 failed, try BSD format
      if "_dateparsefailure_iso" in [tags] {
        mutate { remove_tag => ["_dateparsefailure_iso"] }
        
        date {
          match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
          target => "@timestamp"
          timezone => "Asia/Ho_Chi_Minh"
        }
      }
    }
    
    # Clean up
    mutate {
      remove_field => [ "syslog_version", "syslog_pri", "syslog_timestamp" ]
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "pfsense-%{+YYYY.MM.dd}"
    template_name => "pfsense"
    template_overwrite => true
  }
  
  # Uncomment để debug
  # stdout { codec => rubydebug }
}

# input {
#   udp {
#     port => 5140
#     type => "syslog"
#   }
#   tcp {
#     port => 5140
#     type => "pfsense"
#   }
# }

# filter {
#   if [type] == "pfsense" {
#     # 1. Tách Header Syslog (Chuẩn RFC 5424)
#     # Pattern này khớp với log mẫu: <134>1 2025... pfSense.home.arpa filterlog ...
#     grok {
#       match => { "message" => "^<%{POSINT:syslog_pri}>1 %{TIMESTAMP_ISO8601:log_timestamp} %{HOSTNAME:hostname} %{WORD:program} %{INT:pid} - - %{GREEDYDATA:filter_message}" }
#     }

#     # 2. Lấy thông tin cơ bản để kiểm tra phiên bản IP
#     csv {
#       source => "filter_message"
#       separator => ","
#       columns => [
#         "rule_number","sub_rule_number","anchor","tracker","real_interface","reason","action","dir","ip_version"
#       ]
#       # Chưa lấy hết dữ liệu vội, chỉ lấy đoạn đầu để check
#       autogenerate_column_names => false
#     }

#     # 3. QUAN TRỌNG: Nếu không phải IPv4 thì vứt bỏ ngay lập tức
#     if [ip_version] != "4" {
#       drop {}
#     }

#     # 4. Nếu là IPv4, phân tích chi tiết toàn bộ chuỗi
#     # Cấu trúc chuẩn của pfSense IPv4 TCP/UDP
#     csv {
#       source => "filter_message"
#       separator => ","
#       columns => [
#         "rule_number","sub_rule_number","anchor","tracker","real_interface","reason","action","dir","ip_version",
#         "tos","ecn","ttl","id","offset","flags","proto_id","proto_name",
#         "length","src_ip","dst_ip",
#         "src_port","dst_port","data_length","tcp_flags","sequence_number","ack","window","urg","options"
#       ]
#     }

#     # 5. Xử lý dữ liệu để vẽ biểu đồ
    
#     # Chỉnh sửa lại thời gian theo log thay vì thời gian nhận
#     date {
#       match => [ "log_timestamp", "ISO8601" ]
#       target => "@timestamp"
#     }

#     # Chuyển đổi số liệu (Port scan cần cái này nhất để ra biểu đồ)
#     mutate {
#       convert => {
#         "src_port" => "integer"
#         "dst_port" => "integer"
#         "length" => "integer"
#         "id" => "integer"
#         "rule_number" => "integer"
#         "tracker" => "integer" # Dùng để lọc theo rule bạn tạo
#       }
#     }
    
#     # Định vị địa lý IP nguồn (Để xem tấn công đến từ nước nào - nếu scan từ Internet)
#     # geoip {
#     #   source => "src_ip"
#     #   target => "geoip"
#     # }

#     # Dọn dẹp các trường rác không cần thiết
#     mutate {
#       remove_field => ["message", "filter_message", "log_timestamp", "syslog_pri", "anchor", "sub_rule_number"]
#     }
#   }
# }

# output {
#   elasticsearch {
#     hosts => ["http://elasticsearch:9200"] # Chỉnh lại IP/Host nếu cần
#     index => "pfsense-ipv4-%{+YYYY.MM.dd}"
#     manage_template => false
#   }
# }
